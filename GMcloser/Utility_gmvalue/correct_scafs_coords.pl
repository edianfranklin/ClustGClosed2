#!/usr/bin/env perl
use warnings;
use strict;
use Getopt::Long;
use Pod::Usage;
use FindBin qw($Bin);

# Generate a scaffold fasta file whose scaffolds are broken at misassembled positions
# The misassembled positions are obtained from '*.coords' file

my $scaf_file = '';
my $coords_file = '';
my $subcontig_file = '';
my $ref_file = '';
my $min_identity = 97;
my $min_coverage = 99;
my $min_align_len = 200;
my $min_subcon_len = 200;
my $max_gap_len = 50000;
my $max_indel_size = 100;
my $prefix_out = 'out';
my $error_correct = 0;
my $help;

GetOptions(
    'query|q=s' => \$scaf_file,
    'align|a=s' => \$coords_file,
    'subcon|s=s' => \$subcontig_file,
    'ref|r=s' => \$ref_file,
    'min_id|mi=i' => \$min_identity,
    'min_cov|mc=i' => \$min_coverage,
    'min_len|ml=i' => \$min_subcon_len,
    'min_align|ma=i' => \$min_align_len,
    'max_gap|mg=i' => \$max_gap_len,
    'max_indel|is=i' => \$max_indel_size,
    'prefix|p=s' => \$prefix_out,
    'enable_out|e' => \$error_correct,
    'help' => \$help
) or pod2usage(-verbose => 0);

pod2usage(-verbose => 0) if $help;
pod2usage(-verbose => 0) if ($scaf_file eq '');
pod2usage(-verbose => 0) if ($coords_file eq '');

=head1 SYNOPSIS

  GMvalue ver. 1.3

  Options:
   --query or -q <STR>      input scaffold fasta file (e.g., scaf.fa)
   --subcon or -s <STR>     input subcontig file, generated by contig-splitting of scaffolds (e.g., scaf.subcontig.fasta)
   --ref or -r <STR>        input reference file (e.g., ref.fa)
   --align or -a <STR>      input coords file from Nucmer outputs (e.g., align.coords)
   --min_id or -mi <INT>    minimum alignment identity (%) [default: 97]
   --min_cov or -mc <INT>   minimum coverage (%) of query (contig) aligned to a reference [default: 99]
   --min_align or -ma <INT> minimum alignment overlap length with the maximum allowable size of indels [default: 200]
   --min_len or -ml <INT>   minimum contig length to be considered [default: 200]
   --prefix or -p <STR>     prefix name of outputs
   --error_correct or -e    output an error-corrected contig set [default: false]
   --max_gap or -mg <INT>   maximum length of gaps contained in the scaffolds [default: 50000]
   --max_indel or -is <INT> maximum allowable size of indels (or distance between break points) [default: 100]
   --thread or -n           number of threads to run [default: 1]
   --help or -h             output help message
   
=cut

my $query_name = '-';
my $Qseq = '';
my %query_seq;
my %gap_seq;
open (FILE, $scaf_file) or die "$!";
while (my $line = <FILE>){
    chomp $line;
    if ($line =~ /^>(\S+)/){
        my $name = $1;
        if ($query_name ne '-'){
            $query_seq{$query_name} = uc $Qseq;
            my $count_gap = 0;
            if ($Qseq =~ /N/){
                while ($Qseq =~ /(N+)/g){
                    ${$gap_seq{$query_name}}{$count_gap} = $1;
                    $count_gap ++;
                }
            }
            $Qseq = '';
        }
        $query_name = $name;
#        if (($query_name !~ /\S+_\d+$/) and ($query_name =~ /([^\d+]+)(\d+)$/)){
#            $query_name = $1 . '_' . $2;
#        }
    }
    else{
        $Qseq .= uc $line;
    }
}
$query_seq{$query_name} = uc $Qseq;
my $count_gap = 0;
if ($Qseq =~ /N/){
    while ($Qseq =~ /(N+)/g){
        ${$gap_seq{$query_name}}{$count_gap} = $1;
        $count_gap ++;
    }
}
$Qseq = '';
close (FILE);

my $subcon_name = '-';
my $prefix_name = '-';
my $subcon_no = 0;
my $subseq = '';
my %subcon_no;
my $zero_base = 0;
my %small_subcon_no;
my %subcon_name;
my %subcon_seq;
my $link_num = 0;
my $indel_num = 0;
my $break_num = 0;

open (FILE, $subcontig_file) or die "$!";
while (my $line = <FILE>){
    chomp $line;
    if ($line =~ /^>(\S+)/){
        if ($subcon_name ne ''){
            if (length $subseq < $min_subcon_len){
                ${$small_subcon_no{$prefix_name}}{$subcon_no} = 1;      # list No. of subcontigs whose length are less than min_subcon_len 
            }
            ${$subcon_seq{$prefix_name}}{$subcon_no} = $subseq;
            $subseq = '';
            $prefix_name = '';
            $subcon_no = 0;
        }
        $subcon_name{$subcon_name} = 1;
        $subcon_name = $1;
        if ($subcon_name =~ /^(\S+)\/(\d+)$/){
            $prefix_name = $1;
            $subcon_no = $2;
            $subcon_no{$prefix_name} ++;
            $link_num ++ if ($2 > 0);
            $zero_base = 1 if $subcon_no == 0;
        }
    }
    else{
        $subseq .= $line;
    }
}
if (length $subseq < $min_subcon_len){
    ${$small_subcon_no{$prefix_name}}{$subcon_no} = 1;
}
$subcon_name{$subcon_name} = 1;
${$subcon_seq{$prefix_name}}{$subcon_no} = $subseq;
close (FILE);

my $non_scaf_num = 0;

foreach my $name (keys %subcon_no){
    $non_scaf_num ++ if ($subcon_no{$name} == 1);
}

my %ref_seq;
my $seq = '';
my $chr = '';
open (FILE, $ref_file) or die "$!";
while (my $line = <FILE>){
    chomp $line;
    if ($line =~ /^>(\S+)/){
        if ($seq ne ''){
            $ref_seq{$chr} = $seq;
            $seq = '';
        }
        $chr = $1;
    }
    else{
        $seq .= $line;
    }
}
$ref_seq{$chr} = $seq;
$seq = '';
close (FILE);

my %align;
my %partial_match;
my %scaf_break_pos;
my %aligned_query;
my %aligned_query_subcon;

my %broken_query_seq;
my %misassemble_query;

my $ref_name = '-';
open (FILE, $coords_file) or die "$!";
while (my $line = <FILE>){          # extract information on scaffolds (its subcontigs)-reference alignments
    chomp $line;
    next if ($line !~ /^\d+/);
    my @line = split (/\s+/, $line);
    my $rstart = $line[0];
    my $rend = $line[1];
    my $overlen = $line[4];
    my $strand = '+' if ($line[3] >= $line[2]);
    $strand = '-' if ($line[2] >= $line[3]);
    my $qstart = $line[2] if ($strand eq '+');
    $qstart = $line[3] if ($strand eq '-');
    my $qend = $line[3] if ($strand eq '+');
    $qend = $line[2] if ($strand eq '-');
    my $identity = $line[6];
    my $qlen = $line[8];
    my $qcov = $line[10];
    my $rname = $line[11];
    my $qname = $line[12];
    my $qbase = $1 if ($qname =~ /(\S+)\/\d+$/);
    my $qsnum = $1 if ($qname =~ /\S+\/(\d+)$/);
    if (($identity >= $min_identity) and ($qcov >= $min_coverage)){
        if (!exists ${${${$align{$qbase}}{$rname}}{$strand}}{$qsnum}){
            ${${${$align{$qbase}}{$rname}}{$strand}}{$qsnum} = "$rstart-$rend";
        }
        else{
            ${${${$align{$qbase}}{$rname}}{$strand}}{$qsnum} .= "|$rstart-$rend";
        }
        $aligned_query{$qbase} = 1;
        ${$aligned_query_subcon{$qbase}}{$qsnum} = 1;
    }
    elsif (($identity >= $min_identity) and ($qcov >= 0.1)){
        if ($max_indel_size > 0){
            ${${${${$partial_match{$qbase}}{$rname}}{$strand}}{$qsnum}}{$rstart} = "$rend==$qlen==$qstart==$qend";
        }
    }
}
close (FILE);

foreach my $qname (keys %partial_match){            # merge proxomal alignments disrupted by an indel with <= min_indel_size
    foreach my $rname (keys %{$partial_match{$qname}}){
        my $rlen = length $ref_seq{$rname};
        foreach my $strand (keys %{${$partial_match{$qname}}{$rname}}){
            foreach my $subno (keys %{${${$partial_match{$qname}}{$rname}}{$strand}}){
                next if (exists ${$aligned_query_subcon{$qname}}{$subno});
                my $pre_rstart = 0;
                my $pre_rend = 0;
                my $pre_qend = 0;
                my $pre_qstart = 0;
                my $count_align = 0;
                my $q_len = 0;
                foreach my $rstart (sort {$a <=> $b} keys %{${${${$partial_match{$qname}}{$rname}}{$strand}}{$subno}}){
                    my $align_num = scalar keys %{${${${$partial_match{$qname}}{$rname}}{$strand}}{$subno}};
                    my ($rend, $qlen, $qstart, $qend) = split (/==/, ${${${${$partial_match{$qname}}{$rname}}{$strand}}{$subno}}{$rstart});
                    $q_len = $qlen;
                    $count_align ++;
                    if ($count_align == 1){                     # considerer the gap regions and the 5'-terminus of the reference
                        if ($strand eq '+'){
                            if ($qstart > 10){
                                if ($rstart <= 2){
                                    $qstart = 1;
                                }
                                elsif ($rstart > 10){
                                    my $upstream_seq = substr ($ref_seq{$rname}, $rstart - $qstart, $qstart - 6) if ($rstart - $qstart >= 0);
                                    $upstream_seq = substr ($ref_seq{$rname}, 0, $rstart - 6) if ($rstart - $qstart < 0);
                                    if ($upstream_seq =~ /^N+$/){
                                        $qstart = 1;
                                    }
                                }
                            }
                        }
                        else{
                            if ($qend <= $qlen - 10){
                                if ($rstart <= 2){
                                    $qend = $qlen;
                                }
                                elsif ($rstart > 10){
                                    my $upstream_seq = substr ($ref_seq{$rname}, $rstart - ($qlen - $qend + 1), $qlen - $qend - 5) if ($rstart - ($qlen - $qend + 1) >= 0);
                                    $upstream_seq = substr ($ref_seq{$rname}, 0, $qlen - $qend - 5) if ($rstart - ($qlen - $qend + 1) < 0);
                                    if ($upstream_seq =~ /^N+$/){
                                        $qend = $qlen;
                                    }
                                }
                            }
                        }
                    }
                    if ($count_align == $align_num){            # considerer the gap regions and the 3'-terminus of the reference
                        if ($strand eq '+'){
                            if ($qend <= $qlen - 10){
                                if ($rend >= $rlen - 2){
                                    $qend = $qlen;
                                }
                                elsif ($rend <= $rlen - 10){
                                    my $downstream_seq = substr ($ref_seq{$rname}, $rend + 4, $qlen - $qend - 5) if ($rend + $qlen - $qend <= $rlen);
                                    $downstream_seq = substr ($ref_seq{$rname}, $rend + 4) if ($rend + $qlen - $qend > $rlen);
                                    if ($downstream_seq =~ /^N+$/){
                                        $qend = $qlen;
                                    }
                                }
                            }
                        }
                        else{
                            if ($qstart > 10){
                                if ($rend >= $rlen - 2){
                                    $qstart = 1;
                                }
                                elsif ($rend <= $rlen - 10){
                                    my $downstream_seq = substr ($ref_seq{$rname}, $rend + 4, $qstart - 5) if ($rend + $qstart <= $rlen);
                                    $downstream_seq = substr ($ref_seq{$rname}, $rend + 4) if ($rend + $qstart > $rlen);
                                    if ($downstream_seq =~ /^N+$/){
                                        $qstart = 1;
                                    }
                                }
                            }
                        }
                    }
                    if ($pre_rend > 0){
                        if ($rend <= $pre_rend){
                            next;
                        }
                        if (($qend > $pre_qend) and ($qstart < $pre_qstart)){
                            $pre_rend = $rend;
                            $pre_rstart = $rstart;
                            $pre_qend = $qend;
                            $pre_qstart = $qstart;
                            next;
                        }
                        my $r_distance = abs ($rstart - $pre_rend);
                        my $q_distance = abs ($qstart - $pre_qend) if ($strand eq '+');
                        $q_distance = abs ($qend - $pre_qstart) if ($strand eq '-');
                        if (($q_distance <= $max_indel_size) and ($r_distance <= $max_indel_size)){
                            $pre_rend = $rend;
                            $pre_qend = $qend if ($strand eq '+');
                            $pre_qstart = $qstart if ($strand eq '-');
                            next;
                        }
                        else{
                            my $total_overlen = $pre_qend - $pre_qstart + 1;
                            if ($total_overlen / $qlen * 100 >= $min_coverage){
                                if (!exists ${${${$align{$qname}}{$rname}}{$strand}}{$subno}){
                                    ${${${$align{$qname}}{$rname}}{$strand}}{$subno} = "$pre_rstart-$pre_rend";
                                }
                                else{
                                    ${${${$align{$qname}}{$rname}}{$strand}}{$subno} .= "|$pre_rstart-$pre_rend";
                                }
                                $aligned_query{$qname} = 1;
                                ${$aligned_query_subcon{$qname}}{$subno} = 1;
                                $indel_num ++;
                            }
                            else{
                                if (!exists ${$aligned_query_subcon{$qname}}{$subno}){
                                    if ($total_overlen >= $min_align_len){
                                        if (!exists ${${$broken_query_seq{$qname}}{$subno}}{$pre_qstart}){
                                            ${${$broken_query_seq{$qname}}{$subno}}{$pre_qstart} = $total_overlen;
                                        }
                                        else{
                                            my $pre_overlen = ${${$broken_query_seq{$qname}}{$subno}}{$pre_qstart};
                                            if ($total_overlen > $pre_overlen){
                                                ${${$broken_query_seq{$qname}}{$subno}}{$pre_qstart} = $total_overlen;
                                            }
                                        }
                                    }
                                    else{
                                        ${${$misassemble_query{$qname}}{$subno}}{$pre_qstart} = $total_overlen;
                                    }
                                }
                            }
                        }
                    }
                    $pre_rstart = $rstart;
                    $pre_rend = $rend;
                    $pre_qend = $qend;
                    $pre_qstart = $qstart;
                }
                my $total_overlen = $pre_qend - $pre_qstart + 1;
                if ($total_overlen / $q_len * 100 >= $min_coverage){
                    if (!exists ${${${$align{$qname}}{$rname}}{$strand}}{$subno}){
                        ${${${$align{$qname}}{$rname}}{$strand}}{$subno} = "$pre_rstart-$pre_rend";
                    }
                    else{
                        ${${${$align{$qname}}{$rname}}{$strand}}{$subno} .= "|$pre_rstart-$pre_rend";
                    }
                    $aligned_query{$qname} = 1;
                    ${$aligned_query_subcon{$qname}}{$subno} = 1;
                    $indel_num ++;
                }
                else{
                    if (!exists ${$aligned_query_subcon{$qname}}{$subno}){
                        if ($total_overlen >= $min_align_len){
                            if (!exists ${${$broken_query_seq{$qname}}{$subno}}{$pre_qstart}){
                                ${${$broken_query_seq{$qname}}{$subno}}{$pre_qstart} = $total_overlen;
                            }
                            else{
                                my $pre_overlen = ${${$broken_query_seq{$qname}}{$subno}}{$pre_qstart};
                                if ($total_overlen > $pre_overlen){
                                    ${${$broken_query_seq{$qname}}{$subno}}{$pre_qstart} = $total_overlen;
                                }
                            }
                        }
                        else{
                            ${${$misassemble_query{$qname}}{$subno}}{$pre_qstart} = $total_overlen;
                        }
                    }
                }
            }
        }
    }
}


my %align_subcon;
foreach my $qname (keys %align){
    foreach my $rname (keys %{$align{$qname}}){
        foreach my $strand (keys %{${$align{$qname}}{$rname}}){
            foreach my $subno (sort {$a <=> $b} keys %{${${$align{$qname}}{$rname}}{$strand}}){
                ${${$align_subcon{$qname}}{$subno}}{$rname} = "$strand==${${${$align{$qname}}{$rname}}{$strand}}{$subno}";
            }
        }
    }
}

my %gragh;
my $pre_qname = '';

foreach my $qname (keys %align){            # extract query subcontig connection graghs
    my $pre_rname = '';
    $pre_qname = $qname if ($pre_qname eq '');
    foreach my $rname (keys %{$align{$qname}}){
        my $pre_strand = '';
        $pre_rname = $rname if ($pre_rname eq '');
        foreach my $strand (keys %{${$align{$qname}}{$rname}}){
            my $pre_subno = -1;
            my @pre_range;
            my $pre_gragh = '';
            foreach my $subno (sort {$a <=> $b} keys %{${${$align{$qname}}{$rname}}{$strand}}){
                my @range = split (/\|/, ${${${$align{$qname}}{$rname}}{$strand}}{$subno});
                if ($pre_subno == -1){
                    $pre_gragh = $subno;
                }
                else{
                    foreach my $range (@range){
                        my ($rstart, $rend) = split (/-/, $range);
                        foreach my $pre_range (@pre_range){
                            my $pre_gragh_end = $1 if ($pre_gragh =~ /(\d+)$/);
                            my ($pre_rstart, $pre_rend) = split (/-/, $pre_range);
                            if ($strand eq '+'){
                                $pre_gragh .= '====' . $subno if ($rstart - $pre_rend <= $max_gap_len * ($subno - $pre_gragh_end)) and ($subno != $pre_gragh_end);
                            }
                            else{
                                $pre_gragh .= '====' . $subno if ($pre_rstart - $rend <= $max_gap_len * ($subno - $pre_gragh_end)) and ($subno != $pre_gragh_end);
                            }
                        }
                    }
                }
                $pre_subno = $subno;
                @pre_range = (@range);
            }
            $pre_strand = $strand;
            my $start = $1 if ($pre_gragh =~ /^(\d+)/);
            if (!exists ${$gragh{$qname}}{$start}){
                ${$gragh{$qname}}{$start} = $pre_gragh;
            }
            else{
                ${$gragh{$qname}}{$start} = $pre_gragh if (length $pre_gragh > length ${$gragh{$qname}}{$start})
            }
        }
        $pre_rname = $rname;
    }
    $pre_qname = $qname;
}

foreach my $qname (keys %gragh){            # trim overlapped subcontigs in graghs
    my %linked_subno;
    my $count = 0;
    foreach my $start (sort {length ${$gragh{$qname}}{$b} <=> length ${$gragh{$qname}}{$a}} keys %{$gragh{$qname}}){
        my $gragh = ${$gragh{$qname}}{$start};
        $count ++;
        my @subcons = split (/====/, $gragh);
        my $new_gragh = '';
        my %new_gragh;
        foreach my $subno (@subcons){
            if ($count == 1){
                $linked_subno{$subno} = 1;
            }
            else{
                if (!exists $linked_subno{$subno}){
                    $new_gragh .= "====$subno";
                    $linked_subno{$subno} = 1;
                }
                else{
                    if ($new_gragh ne ''){
                        $new_gragh =~ s/^====//;
                        my $start_2 = $1 if ($new_gragh =~ /^(\d+)/);
                        $new_gragh{$start_2} = $new_gragh;
                        $new_gragh = '';
                    }
                }
            }
        }
        if ($count > 1){
            delete ${$gragh{$qname}}{$start};
        }
        if (scalar keys %new_gragh > 0){
            foreach my $st (keys %new_gragh){
                ${$gragh{$qname}}{$st} = $new_gragh{$st};
            }
        }
        if ($new_gragh ne ''){
            $new_gragh =~ s/^====//;
            my $new_start = $1 if $new_gragh =~ /^(\d+)/;
            ${$gragh{$qname}}{$new_start} = $new_gragh;
        }
    }
}

my %break_subno;
foreach my $qname (keys %gragh){            # break inconsistent graghs
    my %linked_subno;
    my $count = 0;
    foreach my $start (sort {$a <=> $b} keys %{$gragh{$qname}}){
        my $gragh = ${$gragh{$qname}}{$start};
        my @subcons = split (/====/, $gragh);
        my $pre_subno = -1;
        my $subno_str = '';
        $count ++;
        ${$break_subno{$qname}}{$start} = 1 if ($count > 1);
        foreach my $subno (@subcons){
            next if ($subno == $pre_subno);
            if (($pre_subno > -1) and ($subno > $pre_subno + 1)){
                my $first_subno = $1 if ($subno_str =~ /^(\d+)/);
                ${$gragh{$qname}}{$first_subno} = $subno_str;
                $subno_str = $subno;
            }
            else{
                if ($subno_str eq ''){
                    $subno_str = $subno;
                }
                else{
                    $subno_str .= "====$subno";
                }
            }
            $pre_subno = $subno;
        }
        if ($subno_str ne ''){
            my $first_subno = $1 if ($subno_str =~ /^(\d+)/);
            ${$gragh{$qname}}{$first_subno} = $subno_str;
            $subno_str = '';
        }
    }
}

my %gragh_assemble;
foreach my $qname (keys %gragh){            # merge gragh
    my $assembled_gragh = '';
    foreach my $start (sort {$a <=> $b} keys %{$gragh{$qname}}){
        my $gragh = ${$gragh{$qname}}{$start};
        if (exists ${$break_subno{$qname}}{$start}){
            if ($assembled_gragh eq ''){
                $assembled_gragh = $gragh;
            }
            else{
                $assembled_gragh .= "||$gragh";
            }
            $break_num ++;
        }
        else{
            if ($assembled_gragh eq ''){
                $assembled_gragh = $gragh;
            }
            else{
                $assembled_gragh .= "====$gragh";
            }
        }
    }
    $gragh_assemble{$qname} = $assembled_gragh;
}

my %mis_assembled_qname;
my %unaligned_subcon;
my %broken_query;

foreach my $qname (keys %gragh_assemble){
    my $break_num = 0;
    my $first_subcon = 1;
    $first_subcon = 0 if ($zero_base == 1);
    my $gragh = $gragh_assemble{$qname};
#print STDERR "$qname\t$gragh\n";
    my $substart = 0;
    my $subend = 0;
    $substart = $1 if ($gragh =~ /^(\d+)/);
    $subend = $1 if ($gragh =~ /(\d+)$/);
    my $subconlen_200_flag = 0;
    if ($substart > $first_subcon){
        my $subcon_no = $first_subcon;
        while ($substart > $subcon_no){
            $subconlen_200_flag = 1 if (!exists ${$small_subcon_no{$qname}}{$subcon_no});
            $subcon_no ++;
        }
        if ($subconlen_200_flag == 1){
#            $scaf_break_pos{$qname} ++;
            my $qname_sub = "$first_subcon-" . ($substart - 1) if ($substart - 1 > $first_subcon);
            $qname_sub = "$first_subcon" if ($substart - 1 == $first_subcon);
            ${$mis_assembled_qname{$qname}}{$substart} = "$qname_sub\tcontig-misassembly";
            if ($qname_sub !~ /-/){
                ${$unaligned_subcon{$qname}}{$first_subcon} = 1;
            }
            else{
                for (my $i = $first_subcon; $i <= $substart - 1; $i++){
                    ${$unaligned_subcon{$qname}}{$i} = 1;
                }
            }
        }
    }
    my $last_subcon = $subcon_no{$qname} if ($zero_base == 0);
    $last_subcon = $subcon_no{$qname} - 1 if ($zero_base == 1);
    $subconlen_200_flag = 0;
    if ($subend < $last_subcon){
        my $subcon_no = $subend + 1;
        while ($last_subcon >= $subcon_no){
            $subconlen_200_flag = 1 if (!exists ${$small_subcon_no{$qname}}{$subcon_no});
            $subcon_no ++;
        }
        if ($subconlen_200_flag == 1){
#            $scaf_break_pos{$qname} ++;
            my $qname_sub = ($subend + 1) . "-" . $last_subcon if ($subend + 1 < $last_subcon);
            $qname_sub = $last_subcon if ($subend + 1 == $last_subcon);
            ${$mis_assembled_qname{$qname}}{$subend} = "$qname_sub\tcontig-misassembly";
            if ($qname_sub !~ /-/){
                ${$unaligned_subcon{$qname}}{$last_subcon} = 1;
            }
            else{
                for (my $i = $subend + 1; $i <= $last_subcon; $i++){
                    ${$unaligned_subcon{$qname}}{$i} = 1;
                }
            }
        }
    }
    
    my @sub_gragh = split (/\|\|/, $gragh);
    my $pre_subgragh = '';
    foreach my $subgragh (@sub_gragh){
        if ($pre_subgragh ne ''){
            my $last_pregragh_subno = $1 if ($pre_subgragh =~ /(\d+)$/);
            my $first_gragh_subno = $1 if ($subgragh =~ /^(\d+)/);
            $subconlen_200_flag = 1;
            if ($pre_subgragh !~ /====/){
                $subconlen_200_flag = 0 if (exists ${$small_subcon_no{$qname}}{$pre_subgragh});
            }
            if ($subgragh !~ /====/){
                $subconlen_200_flag = 0 if (exists ${$small_subcon_no{$qname}}{$subgragh});
            }
            if ($subconlen_200_flag == 1){
                $scaf_break_pos{$qname} ++;
                my $qname_sub = $last_pregragh_subno . "-" . $first_gragh_subno;
                ${$mis_assembled_qname{$qname}}{$last_pregragh_subno} = "$qname_sub\tmislink";
                $broken_query{$qname} = 1;
            }
            if ($first_gragh_subno > $last_pregragh_subno + 1){
                my $subcon_no = $last_pregragh_subno + 1;
                $subconlen_200_flag = 0;
                while ($first_gragh_subno > $subcon_no){
                    $subconlen_200_flag = 1 if (!exists ${$small_subcon_no{$qname}}{$subcon_no});
                    $subcon_no ++;
                }
                if ($subconlen_200_flag == 1){
#                    $scaf_break_pos{$qname} ++;
                    my $qname_sub = ($last_pregragh_subno + 1) . "-" . ($first_gragh_subno - 1) if ($last_pregragh_subno + 1 != $first_gragh_subno - 1);
                    $qname_sub = ($last_pregragh_subno + 1) if ($last_pregragh_subno + 1 == $first_gragh_subno - 1);
                    my $start = $last_pregragh_subno + 1;
                    ${$mis_assembled_qname{$qname}}{$start} = "$qname_sub\tcontig-misassembly";
                    if ($qname_sub !~ /-/){
                        ${$unaligned_subcon{$qname}}{$last_pregragh_subno + 1} = 1;
                    }
                    else{
                        for (my $i = $last_pregragh_subno + 1; $i <= $first_gragh_subno - 1; $i++){
                            ${$unaligned_subcon{$qname}}{$i} = 1;
                        }
                    }
                } 
            }
        }
        my @subcons = split (/====/, $subgragh);
        my $pre_sub = -1;
        $pre_sub = -1 if ($zero_base == 1);
        foreach my $subno (@subcons){
            if ($pre_sub > -1){
                if ($subno > $pre_sub + 1){
                    my $subcon_no = $pre_sub + 1;
                    $subconlen_200_flag = 0;
                    while ($subno > $subcon_no){
                        $subconlen_200_flag = 1 if (!exists ${$small_subcon_no{$qname}}{$subcon_no});
                        $subcon_no ++;
                    }
                    if ($subconlen_200_flag == 1){
#                       $scaf_break_pos{$qname} ++;
                        my $qname_sub = ($pre_sub + 1) . "-" . ($subno - 1) if ($pre_sub + 1 != $subno - 1);
                        $qname_sub = ($pre_sub + 1) if ($pre_sub + 1 == $subno - 1);
                        my $start = $pre_sub + 1;
                        ${$mis_assembled_qname{$qname}}{$start} = "$qname_sub\tcontig-misassembly";
                        if ($qname_sub !~ /-/){
                            ${$unaligned_subcon{$qname}}{$pre_sub + 1} = 1;
                        }
                        else{
                            for (my $i = $pre_sub + 1; $i <= $subno - 1; $i++){
                                ${$unaligned_subcon{$qname}}{$i} = 1;
                            }
                        }
                    }
                }
            }
            $pre_sub = $subno;
        }
        $pre_subgragh = $subgragh;
    }
}


my $total_misassemble_num = 0;
my $misassemble_query_num = scalar keys %scaf_break_pos;
my $total_query_num = scalar keys %query_seq;
my $total_scaf_num = $total_query_num - $non_scaf_num;
my $aligned_query_num = scalar keys %aligned_query;
#my $unaligned_query_num = $total_query_num - $aligned_query_num;


#foreach my $qname (keys %scaf_break_pos){
#    $total_misassemble_num += $scaf_break_pos{$qname};
#}

my %misassembled_subcontig;
my %unaligned_subcon_query;
my %broken_scaf_seq;
my $count_unmatch_flag = 0;

my $out_stat_file = $prefix_out . '.stat.txt';
my $out_misassemble_name_file = $prefix_out . '.misassemble.scaf.list.txt';

open (OUT, "> $out_misassemble_name_file");     # output misassembled and unmapped query names
    print OUT "<< Mis-linked scaffold names >>\n\n";
    foreach my $qname (sort keys %mis_assembled_qname){
        foreach my $start (sort {$a <=> $b} keys %{$mis_assembled_qname{$qname}}){
            ${$mis_assembled_qname{$qname}}{$start} =~ s/====/==/g;
            my ($sub_range, $tag) = split (/\t/, ${$mis_assembled_qname{$qname}}{$start});
            if ($tag eq 'contig-misassembly'){
#                if (exists ${$aligned_query_subcon{$qname}}{$sub_range}){
#                    $misassemble_query_num --;
#                    $total_misassemble_num --;
#                    next;
#                }
            }
            else{
                print OUT "$qname\t${$mis_assembled_qname{$qname}}{$start}\n";
            }
        }
    }
close (OUT);

open (OUT, "> $out_stat_file");
    my $unmapped_query_num = $total_query_num - $aligned_query_num;
    my $truely_assemble_num = $aligned_query_num - $misassemble_query_num;
    my $rate_misassemble_query = int ($misassemble_query_num / $aligned_query_num * 1000) / 10;
    my $rate_truely_assemble_query = int ($truely_assemble_num / $aligned_query_num * 1000) / 10;
    my $rate_unmapped_query = int ($unmapped_query_num / $total_query_num * 1000) / 10;
    my $rate_misassemble_link = 0;
    $rate_misassemble_link = int ($total_misassemble_num / $link_num * 1000) / 10 if ($link_num > 0);
    my $rate_mislink_link = 0;
    $rate_mislink_link = int ($break_num / $link_num * 1000) / 10 if ($link_num > 0);
    print OUT "<< Scaffold subcontig-linking >>\n\n";
    print OUT "Number of scaffolds: $total_query_num\n";
    print OUT "Number of scaffolds with gaps: $total_scaf_num\n";
    print OUT "Total number of misassembled scaffolds = $misassemble_query_num ($rate_misassemble_query%)\n";
    print OUT "Total number of truely assembled scaffolds = $truely_assemble_num ($rate_truely_assemble_query%)\n";
    print OUT "Total subcontig-links in scaffolds  = $link_num\n";
    print OUT "Total number of mislinking events   = $break_num ($rate_mislink_link%)\n";
    print OUT "Mislinking events / subcontig-links = $rate_mislink_link%\n";
    print OUT "Number of unmapped scaffolds = $unmapped_query_num ($rate_unmapped_query%)\n\n";  
    
    print STDERR "<< Scaffold subcontig-linking >>\n";
    print STDERR "Total subcontig-links in scaffolds  = $link_num\n";
    print STDERR "Total number of mislinking events   = $break_num\n";
    print STDERR "Mislinking events / subcontig-links = $rate_mislink_link%\n";
    print STDERR "Number of unmapped scaffolds = $unmapped_query_num ($rate_unmapped_query%)\n\n";
    
close (OUT);

system ("$Bin/correct_subcontigs_coords.pl -q $subcontig_file -a $coords_file -r $ref_file -p $prefix_out");

if ($error_correct == 1){
    open (FILE, "$prefix_out.misassemble.subcontig.list.txt");
    while (my $line = <FILE>){
        chomp $line;
        my ($subconname, $pos1, $pos2) = split (/\t/, $line);
        my $basename = $1 if ($subconname =~ /(\S+)\/\d+$/);
        my $subno = $1 if ($subconname =~ /\S+\/(\d+)$/);
        if (!exists ${$misassembled_subcontig{$basename}}{$subno}){
            ${$misassembled_subcontig{$basename}}{$subno} = $pos2 - $pos1 + 1;
        }
        else{
            ${$misassembled_subcontig{$basename}}{$subno} = $pos2 - $pos1 + 1 if (${$misassembled_subcontig{$basename}}{$subno} < $pos2 - $pos1 + 1)
        }
    }
    close (FILE);
    
    foreach my $qname (keys %query_seq){
        foreach my $num (sort {$a <=> $b} keys %{$subcon_seq{$qname}}){
            if (!exists ${$align_subcon{$qname}}{$num}){
                my $match_flag = &replace_subcon ($qname, $num, 'u');
                $unaligned_subcon_query{$qname} = 1;
            }
        }
        if (!exists $mis_assembled_qname{$qname}){
            if (exists $misassembled_subcontig{$qname}){
                foreach my $subno (sort {$a <=> $b} keys %{$misassembled_subcontig{$qname}}){
                    my $match_flag = &replace_subcon ($qname, $subno, 'm');
                }
            }
        }
        else{
            my $pre_end = 0;
            my $break_count = 0;
            if (exists $broken_query{$qname}){
                foreach my $num (sort {$a <=> $b} keys %{$mis_assembled_qname{$qname}}){
                    my ($sub_range, $tag) = split (/\t/, ${$mis_assembled_qname{$qname}}{$num});
                    if ($tag eq 'mislink'){
                        my ($start, $end) = split (/-/, $sub_range);
                        $break_count ++;
                        my $scaf_seq = '';
                        for (my $i = $pre_end; $i <= $start; $i++){
                            if (exists ${$misassembled_subcontig{$qname}}{$i}){
                                my $match_flag = &replace_subcon ($qname, $i, 'm');
                            }
                            elsif (exists ${$unaligned_subcon{$qname}}{$i}){
                                my $match_flag = &replace_subcon ($qname, $i, 'u');
                            }
                            my $subseq = ${$subcon_seq{$qname}}{$i};
                            $subseq = 'N' x length $subseq if (length $subseq < $min_align_len);
                            $scaf_seq .= $subseq;
                            $scaf_seq .= ${$gap_seq{$qname}}{$i} if (exists ${$gap_seq{$qname}}{$i});
                        }
                        $scaf_seq =~ s/^N+// if ($scaf_seq =~ /^N+/);
                        $scaf_seq =~ s/N+$// if ($scaf_seq =~ /N+$/);
                        ${$broken_scaf_seq{$qname}}{$break_count} = $scaf_seq;
                        $pre_end = $end;
                    }
                }
                my $last_subcon = $subcon_no{$qname} - 1;
                $break_count ++;
                my $scaf_seq = '';
                for (my $i = $pre_end; $i <= $last_subcon; $i++){
                    if (exists ${$misassembled_subcontig{$qname}}{$i}){
                        my $match_flag = &replace_subcon ($qname, $i, 'm');
                    }
                    elsif (exists ${$unaligned_subcon{$qname}}{$i}){
                        my $match_flag = &replace_subcon ($qname, $i, 'u');
                    }
                    my $subseq = ${$subcon_seq{$qname}}{$i};
                    $subseq = 'N' x length $subseq if (length $subseq < $min_align_len);
                    $scaf_seq .= $subseq;
                    $scaf_seq .= ${$gap_seq{$qname}}{$i} if (exists ${$gap_seq{$qname}}{$i});
                }
                $scaf_seq =~ s/^N+// if ($scaf_seq =~ /^N+/);
                $scaf_seq =~ s/N+$// if ($scaf_seq =~ /N+$/);
                ${$broken_scaf_seq{$qname}}{$break_count} = $scaf_seq;
            }
            else{
                foreach my $num (sort {$a <=> $b} keys %{$subcon_seq{$qname}}){
                    if (exists ${$misassembled_subcontig{$qname}}{$num}){
                        my $match_flag = &replace_subcon ($qname, $num, 'm');
                    }
                    if (exists ${$unaligned_subcon{$qname}}{$num}){
                        my $match_flag = &replace_subcon ($qname, $num, 'u');
                    }
                }
            }
        }
    }
    
    my $corrected_scaf_file = $prefix_out . '.corrected.fa';
    open (OUT, "> $corrected_scaf_file");
    foreach my $qname (sort keys %subcon_seq){
        my $scaf_seq = '';
        my $qname_base = $qname;
        $qname_base = $1 if ($qname =~ /(\S+)\|/);
        if (exists $broken_scaf_seq{$qname}){
            foreach my $num (sort {$a <=> $b} keys %{$broken_scaf_seq{$qname}}){
                $scaf_seq = ${$broken_scaf_seq{$qname}}{$num};
                if (length $scaf_seq >= $min_align_len){
                    print OUT ">$qname_base:$num\n";
                    print OUT $scaf_seq, "\n";
                }
            }
        }
        else{
            foreach my $num (sort {$a <=> $b} keys %{$subcon_seq{$qname}}){
                my $subseq = ${$subcon_seq{$qname}}{$num};
                $subseq = 'N' x length $subseq if (length $subseq < $min_align_len);
                $scaf_seq .= $subseq;
                $scaf_seq .= ${$gap_seq{$qname}}{$num} if (exists ${$gap_seq{$qname}}{$num});
            }
            $scaf_seq =~ s/^N+// if ($scaf_seq =~ /^N+/);
            $scaf_seq =~ s/N+$// if ($scaf_seq =~ /N+$/);
            if (length $scaf_seq >= $min_align_len){
                print OUT ">$qname_base\n";
                print OUT $scaf_seq, "\n";
            }
        }
    }
    close (OUT);
}


#print STDERR "Unasigned subcontigs: $count_unmatch_flag\n";

sub replace_subcon{
    my ($qname, $subno, $tag) = @_;
    my $common_ref = '';
    my $up_subcon_pos = 0;
    my $match_flag = 1;
    if (($subno > 0) and (exists ${$align_subcon{$qname}}{$subno - 1})){
        if (scalar keys %{${$align_subcon{$qname}}{$subno - 1}} > 1){
            foreach (keys %{${$align_subcon{$qname}}{$subno - 1}}){
                if (exists ${${$align_subcon{$qname}}{$subno + 1}}{$_}){
                    $common_ref = $_;
                    last;
                }
            }
            if ($common_ref eq ''){
                foreach (keys %{${$align_subcon{$qname}}{$subno - 1}}){
                    my ($strand, $ranges) = split (/==/, ${${$align_subcon{$qname}}{$subno - 1}}{$_});
                    if (exists ${${${$partial_match{$qname}}{$_}}{$strand}}{$subno}){
                        $common_ref = $_ ;
                        last;
                    }
                }
            }
        }
        else{
            foreach (keys %{${$align_subcon{$qname}}{$subno - 1}}){
                $common_ref = $_;
            }
        }
        if ($common_ref ne ''){
            my ($strand, $ranges) = split (/==/, ${${$align_subcon{$qname}}{$subno - 1}}{$common_ref});
            if ($ranges =~ /\|/){
                $match_flag = 0;
            }
            else{
                my $subst_seq = '';
                my ($start, $end) = split (/-/, $ranges);
                my $gap_len = 0;
                my $subcon_len = 0;
                $gap_len = length ${$gap_seq{$qname}}{$subno - 1} if (exists ${$gap_seq{$qname}}{$subno - 1});
                $subcon_len = ${$misassembled_subcontig{$qname}}{$subno} if ($tag eq 'm');
                $subcon_len = length ${$subcon_seq{$qname}}{$subno} if ($tag eq 'u');
                if ($strand eq '+'){
                    $up_subcon_pos = $end;
                    $subst_seq = substr ($ref_seq{$common_ref}, $up_subcon_pos + $gap_len, $subcon_len);
                    ${$subcon_seq{$qname}}{$subno} = $subst_seq;
                }
                else{
                    $up_subcon_pos = $start;
                    $subst_seq = substr ($ref_seq{$common_ref}, $up_subcon_pos - $gap_len - $subcon_len - 1, $subcon_len);
                    $subst_seq = reverse $subst_seq;
                    $subst_seq =~ tr/ACGT/TGCA/;
                    ${$subcon_seq{$qname}}{$subno} = $subst_seq;
                }
            }
        }
        else{
            $match_flag = 0;
        }
    }
    elsif (exists ${$align_subcon{$qname}}{$subno + 1}){
        my $dwn_subcon_pos = 0;
        if (scalar keys %{${$align_subcon{$qname}}{$subno + 1}} > 1){
            foreach (keys %{${$align_subcon{$qname}}{$subno + 1}}){
                if (exists ${${$align_subcon{$qname}}{$subno + 2}}{$_}){
                    $common_ref = $_ ;
                    last;
                }
            }
            if ($common_ref eq ''){
                foreach (keys %{${$align_subcon{$qname}}{$subno + 1}}){
                    my ($strand, $ranges) = split (/==/, ${${$align_subcon{$qname}}{$subno + 1}}{$_});
                    if (exists ${${${$partial_match{$qname}}{$_}}{$strand}}{$subno}){
                        $common_ref = $_ ;
                        last;
                    }
                }
            }
        }
        else{
            foreach (keys %{${$align_subcon{$qname}}{$subno + 1}}){
                $common_ref = $_;
            }
        }
        if ($common_ref ne ''){
            my ($strand, $ranges) = split (/==/, ${${$align_subcon{$qname}}{$subno + 1}}{$common_ref});
            if ($ranges =~ /\|/){
                $match_flag = 0;
            }
            else{
                my $subst_seq = '';
                my ($start, $end) = split (/-/, $ranges);
                my $gap_len = 0;
                my $subcon_len = 0;
                $gap_len = length ${$gap_seq{$qname}}{$subno} if (exists ${$gap_seq{$qname}}{$subno});
                $subcon_len = ${$misassembled_subcontig{$qname}}{$subno} if ($tag eq 'm');
                $subcon_len = length ${$subcon_seq{$qname}}{$subno} if ($tag eq 'u');
                if ($strand eq '+'){
                    $dwn_subcon_pos = $start;
                    $subst_seq = substr ($ref_seq{$common_ref}, $dwn_subcon_pos - $gap_len - $subcon_len - 1, $subcon_len);
                    ${$subcon_seq{$qname}}{$subno} = $subst_seq;
                }
                else{
                    $dwn_subcon_pos = $end;
                    $subst_seq = substr ($ref_seq{$common_ref}, $dwn_subcon_pos + $gap_len, $subcon_len);
                    $subst_seq = reverse $subst_seq;
                    $subst_seq =~ tr/ACGT/TGCA/;
                    ${$subcon_seq{$qname}}{$subno} = $subst_seq;
                }
            }
        }
        else{
            $match_flag = 0;
        }
    }
    else{
        $match_flag = 0;
    }
    if ($match_flag == 0){
        my $subst_seq = '';
        $subst_seq = 'N' x length ${$subcon_seq{$qname}}{$subno};
        ${$subcon_seq{$qname}}{$subno} = $subst_seq;
    }
    $count_unmatch_flag ++ if $match_flag == 0;
    return $match_flag;
}
